[{"title":"二叉树基本内容","path":"/2024/03/25/二叉树/","content":"二叉树基本概念 二叉树: 每个节点至多拥有两颗子树, 子树互不相交, 且子树有左右顺序之分 二叉树的五种基本形态: 空树, 根, 根 + 左子树, 根 + 右子树, 根 + 左子树 + 右子树 树的元素: 叶节点: 度为 $0$ 的节点, 用 $n_{0}$ 表示 度为 $1$ 的节点, 用 $n_{1}$ 表示, 度为 $2$ 的节点, 用 $n_{2}$ 表示 度和深度(层次): 节点的度: 节点拥有的子树数目 树的度: 树中节点最大的度 节点的深度: 根节点深度为 $1$, 根的子节点深度为 $2$, 以此类推 树的深度: 树中节点最大深度 其他树: 斜二叉树: 只有左子树或只有右子树(链表) 完美二叉树(满二叉树): 深度为 $d$, 且节点数为 $2^d-1$ 完全二叉树: 节点编号与完美二叉树一致($n_{1} = 1$ $or$ $0$) 二叉树的性质 第 $i$ 层的最大节点数: $2^{i-1}$ 深度为 $d$ 的二叉树最多有 $2^d-1$ 个节点 对任意二叉树, $n_{0} = n_{2} + 1$ 证明: 总结点数 $n = n_{0} + n_{1} + n_{2}$, 总边数 $n_{0} + n_{1} + n_{2} - 1$(根节点无向上的边) $=0n_{0} + 1n_{1} + 2*n_{2}$, 移项即得 二叉树的存储结构 顺序存储 主要用于完全二叉树 非根节点 $i$ 的父节点序号: $\\lfloor i/2 \\rfloor$ 节点 $i$ 的左节点: $2i$ (若 $2i &gt; n$, 无左节点) 节点 $i$ 的右节点: $2i+1$ (若 $2i+1 &gt; n$, 无右节点) 链表存储 二叉树的遍历 前序, 中序, 后序中的前, 中, 后指的是根节点在前, 中, 后被访问. 不论哪种遍历, 都是先左后右 递归实现: 1234567891011void AnyOrderTraversal(BST t)&#123; if (t != nullptr) &#123; // visit(t-&gt;data); 前序遍历访问 AnyOrderTraversal(t-&gt;left); // visit(t-&gt;data); 中序遍历访问 AnyOrderTraversal(t-&gt;left); // visit(t-&gt;data); 后序遍历访问 &#125;&#125; 迭代实现: 前, 中序遍历 思路: 用栈保存”根”节点, 在入栈(前序)或出栈(中序)时访问 12345678910111213141516void Pre_In_OrderTraversal(BST t)&#123; std::stack&lt;T&gt; node; while (t || !node.empty()) &#123; while (t != nullptr) &#123; // visit(t-&gt;data); 前序访问根节点 node.push(t); &#125; t = node.top(); // visit(t-&gt;data); 中序访问根节点 t = t-&gt;right; node.pop(); &#125;&#125;","tags":["二叉树"]},{"title":"Hello World","path":"/2024/03/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]